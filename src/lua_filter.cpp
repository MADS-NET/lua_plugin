/*
  _____ _ _ _                    _             _
 |  ___(_) | |_ ___ _ __   _ __ | |_   _  __ _(_)_ __
 | |_  | | | __/ _ \ '__| | '_ \| | | | |/ _` | | '_ \
 |  _| | | | ||  __/ |    | |_) | | |_| | (_| | | | | |
 |_|   |_|_|\__\___|_|    | .__/|_|\__,_|\__, |_|_| |_|
                          |_|            |___/
# A Template for ScriptPlugin, a Filter Plugin
# Generated by the command: plugin -t filter -d script_plugin script
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2024-08-23T12:09:57.009+0200
# NOTICE: MADS Version 1.0.3
*/
// Mandatory included headers
#include <filter.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
// other includes as needed here
// clang-format off
#include <fstream>
#include <filesystem>
#include <lua.hpp>
#include <lualib.h>
#include <lauxlib.h>
#include <sol/sol.hpp>
#include "utils.hpp"
// clang-format on

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "script"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class ScriptPlugin : public Filter<json, json> {

public:
  ~ScriptPlugin() {
    _lua.collect_garbage();
    _lua.end();
  }

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  return_type load_data(json const &input, string topic = "") override {
    _lua["MADS"]["topic"] = topic;
    try {
      _lua["MADS"]["data"] = MADS::to_table(_lua, input);
    } catch (exception &e) {
      cerr << "Error: " << e.what() << endl;
      return return_type::error;
    }
    return return_type::success;
  }

  return_type process(json &out) override {
    out.clear();

    if (!_agent_id.empty())
      out["agent_id"] = _agent_id;

    try {
      out["payload"] = json::parse(_process(_self));
    } catch (exception &e) {
      cerr << "Error: " << e.what() << endl;
      return return_type::error;
    }

    return return_type::success;
  }

  void set_params(void const *params) override {
    Filter::set_params(params);
    _params["script_file"] = "filter.lua";
    _params["search_paths"] = json::array();
    _params.merge_patch(*(json *)params);

    for (auto &path : _params["search_paths"]) {
      _default_paths.push_back(filesystem::path(path));
    }

    _script_file = _params["script_file"];
    _script_path = filesystem::path(_script_file);
    if (!_script_path.is_absolute()) {
      _script_file = MADS::try_paths(_default_paths, _script_path);
    }
    cout << "Loading script: " << _script_file << endl;
    prepare__lua();
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override {
    return {{"script_file", _script_file}};
  };

private:
  void prepare__lua() {
    _lua.open_libraries(sol::lib::base, sol::lib::package, sol::lib::string,
                        sol::lib::table, sol::lib::math, sol::lib::string, 
                        sol::lib::os, sol::lib::io);
    for (auto &path : _default_paths) {
      if (!path.is_absolute()) {
        path = MADS::exec_dir() / path;
      }
      LUA_ADD_PATH(_lua, path.string() + "/?.lua");
    }
    _lua.script(R"END(
json = require("json")
MADS = {}
function MADS.dump(o)
  if type(o) == 'table' then
     local s = '{'
     for k,v in pairs(o) do
        if type(k) == 'number' then 
          s = s .. k .. ", "
        else 
          s = s .. k .. ": " .. MADS.dump(v) .. ', '
        end
     end
     s = string.sub(s, 1, -3)
     return s .. '}'
  else
    if type(o) == "string" then
      return '"' .. o .. '"'
    else
      return tostring(o)
    end
  end
end
    )END");
    try {
      _lua.script_file(_script_file);
    } catch (sol::error &e) {
      cerr << "Error: " << e.what() << endl;
      exit(EXIT_FAILURE);
    }
    _self = _lua["MADS"];
    if (!_self["process"].valid()) {
      cerr << "Error: the script " << _script_file
           << " must define a function named MADS:process() that returns a "
              "valid JSON string"
           << endl;
      exit(EXIT_FAILURE);
    }
    _process = _self["process"];
  }

  sol::state _lua;
  sol::table _self;
  function<string(sol::table)> _process;
  string _script_file;
  filesystem::path _script_path;
  // those are the defauilt paths where the script can be found
  // RELATIVE to the current executable!
  vector<filesystem::path> _default_paths = {
        "./lua",
        "./scripts",
        "../lua",
        "../scripts",
        INSTALL_PREFIX "/lua",
        INSTALL_PREFIX "/scripts"
      };
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_FILTER_DRIVER(ScriptPlugin, json, json);

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

*/

int main(int argc, char const *argv[]) {
  ScriptPlugin plugin;
  json params;
  json input, output;

  params["script_file"] = "filter.lua";

  if (argc > 1) {
    params["script_file"] = argv[1];
  }
  plugin.set_params(&params);

  plugin.info();

  // Set input data
  input = {{"AX", 1}, {"AY", 2}, {"AZ", 3}};
  input["ary"] = json::array({1, 2.7, 3});

  // Set input data
  plugin.load_data(input, "test_topic");
  cout << "Input: " << input.dump(2) << endl;

  // Process data
  plugin.process(output);
  cout << "Output: " << output.dump(2) << endl;

  return 0;
}
